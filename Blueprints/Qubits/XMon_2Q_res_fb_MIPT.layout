#!/usr/bin/layout
#name=XMon resonators
#help=Creates XMon resonator design

#include "../lib/wiring.layout"
#include "../lib/auxx.layout"
#include "../lib/layersSetup.layout"
#include "../lib/resonator.layout"
#include "../lib/feedline.layout"
#include "../lib/claw.layout"
#include "../lib/Xmon.layout"
#include "../lib/test_JJ.layout"
#include "../lib/alignment_mark.layout"
#include "qr_nbal.layout"
#include "../lib/holes.layout"

        int M = 0;
        int M1 = 1;
	int jj_layer = 2;    
        int protect = 3;
        int ground = 4;
        int mask = 5;
        int total = 6;
        int aux = 7;
        int aux2 = 8;
        int aux3 = 9;
        int aux4 = 10;
        int bandage = 11;
	int aux5 = 12;
//	int error = 13;
	int holes = 14;
        
        int chip_height = 5e6;
        int chip_width = 10e6;
        int border=50e3;
        
        int feedlineDepth = chip_height/4;
        double É› = 11.45;
        double c = 299792458.0;

        doubleList res_freqs;        
        doubleList test_res_freqs;
        
        int w_res = 2*7e3;
        int g_res = 2*4e3;
        int x = 5e3;
        int tailLen = 1000e3;
        int w_thinGround = 5e3;
        int L_claw_left = 60e3;
        int L_claw_right = 60e3;
        int w_claw = 20e3;
        int claw_gap = 8e3;


        int w_feed = 16e3;
        int g_feed = 8e3;
      
        int w_q = 20e3;
        int g_q = 20e3;
        int arm_len = 300e3;
        int ebeam_overlap = 3e3;
        doubleList asymmetries;

        int qrSize = 600e3;
        int qrCodePositionX = chip_width/2*11/10;
        int qrCodePositionY = chip_height/2*11/10;


int main() {
    setupLayers();
    layout->drawing->selectAll();
    layout->drawing->deleteSelect();
    layout->drawing->deselectAll();
//	layout->drawing->activeLayer=error;
//	layout->drcTool->setErrorLayerToActiveLayer();
        
    string sample_name = layout->getText("Sample name","Please enter the sample name:", "Xmon_2Q_fb");
    
        int i;
    
    cell *curCell = layout->drawing->currentCell;
    point cursor;
    
    intList segmentLengths;
    stringList directions;
    directions.append("r");
    
    segmentLengths.append(chip_width);
    cursor.set(-chip_width/2, 0);
    addFeedline(curCell, cursor, w_feed, g_feed, segmentLengths, directions, "cp");
   
   
    // Ground plane
    curCell->addBox(-chip_width/2, -(chip_height)/2, chip_width, chip_height, ground);
    
    int resonatorPositionsX = -chip_width/5;
    int resonatorPositionsY = -w_feed/2-g_feed-x;
    res_freqs.append(7); res_freqs.append(7.1); res_freqs.append(7.2); res_freqs.append(7.3); res_freqs.append(7.4); res_freqs.append(7.5);
    test_res_freqs.append(8); test_res_freqs.append(8.25);

    element* marker;
    point test_cursor = addResonator(curCell, newPoint(-chip_width/2+chip_width/6, -resonatorPositionsY+5*x), w_res, g_res, test_res_freqs.at(0), 0.5e6, "u", 0);
    marker = curCell->addText(protect, newPoint(test_cursor.x()+100e3, test_cursor.y()+600e3), "TI");
    test_cursor = addResonator(curCell, newPoint(chip_width/2-chip_width/6+200e3, resonatorPositionsY-5*x), w_res, g_res, test_res_freqs.at(1), 1e6, "d", 0);
    marker = curCell->addText(protect, newPoint(test_cursor.x()-300e3, test_cursor.y()), "TII");
    
    for (i=0; i<6; i++){
        asymmetries.append(0+0.8/5*i);
    } 
        
    double j = -0.14;
    int k = 0;
    point cursor2;
    point cursor3;
    for (i=0; i<5;i+=2){
        cursor.set(resonatorPositionsX+chip_width/5*(j-0.03), resonatorPositionsY);
        cursor2 = addResonator(curCell, cursor, w_res, g_res, res_freqs.at(k), tailLen, "d", "3");
    //    cursor2 = addClaw(curCell, cursor2, "d");
	L_claw_left = 80e3+k/2*10e3;
	L_claw_right = 80e3+k/2*10e3;
	point cursor4 = addClaw(curCell,  newPoint(cursor2.x()+w_res/2, cursor2.y()), "l");
	L_claw_left = 40e3;
	L_claw_right = 40e3;
        point cursor5 = addClaw(curCell,  newPoint(cursor2.x()-w_res/2, cursor2.y()), "r");

        cursor3.set(cursor2.x()+300e3, cursor2.y()+500e3);
        marker = curCell->addText(protect, cursor3, roman(k+1));
      //  cursor2 = addXmon(curCell, cursor2, "d", 200, 100, asymmetries.at(k));
	point cursor6 = addXmon(curCell, cursor5, "r", 140, 140, asymmetries.at(k+1));
        cursor5 = addXmon(curCell, cursor4, "l", 140, 140, asymmetries.at(k+1));
        

	stringList directions; 
	intList segmentLengths; 

	if (k == 0) {
		directions.append("r"); directions.append("d"); directions.append("l"); directions.append("d"); 
		segmentLengths.append(200e3); 
				segmentLengths.append(300e3);
					segmentLengths.append(-(-1+k/2)/4*chip_width + cursor6.x()+200e3);
						segmentLengths.append(chip_height/2 +cursor6.y()-300e3);
		addFeedline(curCell, cursor6, w_res, g_res, segmentLengths, directions, "fb"); 

	} else if (k == 2) {  
		directions.append("r"); directions.append("d"); directions.append("l"); directions.append("d");
		segmentLengths.append(200e3); segmentLengths.append(300e3);  segmentLengths.append(-(-1+k/2)/4*chip_width + 
									 200e3+ cursor6.x()); segmentLengths.append(chip_height/2 -300e3+cursor6.y());
		addFeedline(curCell, cursor6, w_res, g_res, segmentLengths, directions, "fb"); 

	} else {
		directions.append("r"); directions.append("d");
		segmentLengths.append(200e3+2.5*arm_len -(-(-1+k/2)/4*chip_width + 2.5*arm_len + 
			200e3+ cursor6.x())); segmentLengths.append(chip_height/2 + cursor6.y());  
		addFeedline(curCell, cursor6, w_res, g_res, segmentLengths, directions, "fb"); 

	}
	

        cursor.set(resonatorPositionsX+chip_width/5*(1.*j+0.55), -resonatorPositionsY);
        cursor2 = addResonator(curCell, cursor, w_res, g_res, res_freqs.at(k+1), tailLen, "u", "3");
	L_claw_left = 110e3+(k-1)/2*10e3;
	L_claw_right = 110e3+(k-1)/2*10e3;
        point cursor4 = addClaw(curCell,  newPoint(cursor2.x()+w_res/2, cursor2.y()), "l");
	L_claw_left = 60e3;
	L_claw_right = 60e3;
        point cursor5 = addClaw(curCell,  newPoint(cursor2.x()-w_res/2, cursor2.y()), "r");
        addXmon(curCell, cursor5, "r", 140, 140, asymmetries.at(k+1));
        cursor5 = addXmon(curCell, cursor4, "l", 140, 140, asymmetries.at(k+1));
        
        cursor3.set(cursor2.x()+200e3, cursor2.y()+500e3);
        marker = curCell->addText(protect, cursor3, roman(k+2));

        
        stringList directions; 
       if (k != 4) {
            directions.append("l"); directions.append("u"); 
        } else {
            directions.append("l"); directions.append("u"); directions.append("r"); directions.append("u");
        }
        intList segmentLengths; 
        if (k!=4) {
            segmentLengths.append(-(-1+k/2)/4*chip_width + cursor5.x()); segmentLengths.append(chip_height/2 -cursor5.y()); 
        } else {
            segmentLengths.append(200e3); segmentLengths.append(300e3); segmentLengths.append((-1+k/2)/4*chip_width - cursor5.x()+200e3); segmentLengths.append(chip_height/2 - 300e3-cursor5.y()); 
        } 
        addFeedline(curCell, cursor5, w_res, g_res, segmentLengths, directions, "fb");
        
        j++;
        k+=2;
    }

    curCell->textToPolygon(100e3);

    marker = curCell->addText(protect, newPoint(-chip_width/2+400e3, chip_height/2-400e3), sample_name);    
    curCell->textToPolygon(150e3);
        JJ_pads_len = 4e3+5.65e3;
    addTestSquid(curCell, newPoint(-chip_width/2+0.5e6, 1e6), 200, 100, "l", false, 0);
    addTestSquid(curCell, newPoint(chip_width/2-0.5e6, 1e6), 200, 100, "l", false, 0.2);
    addTestSquid(curCell, newPoint(-chip_width/2+0.5e6, -1e6), 200, 100, "l", false, 0.4);
    addTestSquid(curCell, newPoint(chip_width/2-0.5e6, -1e6), 200, 100, "l", false, 0.8);
/*    */
    addAlignmentMark(curCell, newPoint(chip_width/2-0.5e6, -1.75e6));
    addGlobalAlignmentMarkBMSTU(curCell, newPoint(chip_width/2-0.65e6, -1.75e6+0.025e6));

    addAlignmentMark(curCell, newPoint(-chip_width/2+0.5e6, -1.75e6));
    addGlobalAlignmentMarkBMSTU(curCell, newPoint(-chip_width/2+0.65e6, -1.75e6+0.025e6));
    
    addAlignmentMark(curCell, newPoint(-chip_width/2+0.5e6, 1.75e6));
    addGlobalAlignmentMarkBMSTU(curCell, newPoint(-chip_width/2+0.65e6, 1.75e6-0.025e6));

//  addHoles(curCell);
    
  layout->booleanTool->boolOnLayer(ground, protect, mask, "A-B", 0, 0, 0);
   layout->booleanTool->boolOnLayer(M, mask, total, "A+B", 0, 0, 0);
    layout->booleanTool->boolOnLayer(M1, total, total, "A+B", 0, 0, 0);
    clearLayer(curCell, M1);
    
//   layout->booleanTool->boolOnLayer(protect, M, total, "A-B", 0, 0, 0);
//   curCell->addBox(-chip_width/2-border, -chip_height/2-border, chip_width+border*2, chip_height+border*2, aux);
 //  layout->booleanTool->boolOnLayer(aux, ground, total, "A-B", 0, 0, 0);
 // clearLayer(curCell, aux);



    
    int hd;
    layout->backgroundTool->clearBackground();
/*    hd = layout->backgroundTool->addBackground("background.png");*/
/*    layout->backgroundTool->backgroundOffset(hd, -5682e3, 2950e3);*/
/*    layout->backgroundTool->backgroundScale(hd, 8.3e3, 8.3e3);*/
    clearLayer(curCell, mask);
    clearLayer(curCell, M);
    clearLayer(curCell, protect);
    clearLayer(curCell, ground);
    //debug.show();
    //debug.clear();
    
    
    
}
