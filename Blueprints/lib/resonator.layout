/*
 Coupled lamda/4 resonator.
 
 Coupling point is in the center of coupling area, being offset to the edge of protect layer towards the feedline.
 Schematic:
 
 ===================== <- feedline
  ________x________    <- resonator coupling area 
 |                         |   x - coupling (base) point
*/



#include "wiring.layout"

    int meanderSegmentLength = 250e3;

double claw3PhaseShift(double frequency) {
    return 0.452+6.226*frequency;
}
// Using the fit for ɛ=11.45 and claw length of ~70 um

double clawPhaseShift(double frequency) {
    return 0.014+1.436*frequency;
}

double clawDoublePhaseShift(double frequency) {
    return 0.222+2.222*frequency;
}
    
int length_from_frequency(double frequency, string claw) {
    int base_length = math::sqrt2/2*c/frequency/(math::sqrt(ɛ+1))/1e9/2*1e6;
    if (claw=="1") // for the claw with 1 site
        return base_length - 1./180.*clawPhaseShift(frequency)/frequency/1e9*c/2/math::sqrt(ɛ/2.+1./2.)/2.*1e6;
    else if (claw=="2") // for the claw with two sites for Box
        return base_length - 1./180.*claw3PhaseShift(frequency)/frequency/1e9*c/2/math::sqrt(ɛ/2.+1./2.)/2.*1e6;
     else if (claw=="3") // for the claw with two sites for Xmon
        return base_length - 1./180.*clawDoublePhaseShift(frequency)/frequency/1e9*c/2/math::sqrt(ɛ/2.+1./2.)/2.*1e6;
    else if (claw=="0") // no claw
        return base_length;
}


point drawMeanderStep(cell* curCell, int layer, point cursor, int meanderSegmentLength, int resTurnRad, int width) {
        
        point cursor2 = wire(curCell, layer, cursor, "r", meanderSegmentLength, width);
        cursor2 = torusTurn(curCell, layer, cursor2, "rd", resTurnRad, width);
        cursor2 = torusTurn(curCell, layer, cursor2, "dl", resTurnRad, width);
        cursor2 = wire(curCell, layer, cursor2, "l", meanderSegmentLength, width);
        cursor2 = torusTurn(curCell, layer, cursor2, "ld", resTurnRad, width);
        return torusTurn(curCell, layer, cursor2, "dr", resTurnRad, width);
}

void generateStructure(cell* curCell, point cursor,  int width, int tailLen, int length,  int resTurnRad, int layer) {
    
    int curLength = 0;
    point start;
    start.set(cursor.x(), cursor.y());
    
    cursor = wire(curCell, layer, cursor, "r", 200e3, width);
    curLength+=200e3;
    cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    cursor = wire(curCell, layer, cursor, "d", tailLen, width);
    curLength+=tailLen;
    
    cursor.set(start.x(), start.y());
    
    cursor = wire(curCell, layer, cursor, "l", 200e3, width);
    curLength+=200e3;
    cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    cursor = wire(curCell, layer, cursor, "d", 50e3, width);
    curLength+=50e3;
    cursor = torusTurn(curCell, layer, cursor, "dr", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    
    int meanderStepLength = 2*meanderSegmentLength+2*math::pi*resTurnRad;

    point cursor2;
    while ((length -curLength)>meanderStepLength) {
        cursor = drawMeanderStep(curCell, layer, cursor, meanderSegmentLength, resTurnRad, width);
        curLength+=meanderStepLength;
    }
    
    if (length - curLength >= meanderSegmentLength+2*resTurnRad*math::pi_2) {
        cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength, width);
        cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
        cursor = torusTurn(curCell, layer, cursor, "dl", resTurnRad, width);
        curLength+= meanderSegmentLength+2*resTurnRad*math::pi_2;
        if (length - curLength >= meanderSegmentLength) {
            cursor = wire(curCell, layer, cursor, "l", meanderSegmentLength, width);
            curLength += meanderSegmentLength;
            cursor = torusArbAngleTurn(curCell, layer, cursor, "ld", resTurnRad, width, (length-curLength)/2/math::pi/resTurnRad*360);
        } else {
            cursor = wire(curCell, layer, cursor, "l", length - curLength, width);
        }
    } else if (length - curLength >= meanderSegmentLength) {
        cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength, width);
        curLength+=meanderSegmentLength;
        cursor = torusArbAngleTurn(curCell, layer, cursor, "rd", resTurnRad, width, (length-curLength)/2/math::pi/resTurnRad*360);
    } else {
        cursor = wire(curCell, layer, cursor, "r", length - curLength, width);
        curLength+=length - curLength;
    }
}


point addResonator(cell* curCell, point couplingPoint, int w_res, int g_res, double frequency, int tailLen, string direction, string claw) {
   
    point cursor;
    cursor.set(couplingPoint.x(), couplingPoint.y()-w_res/2 - g_res);
    int length = length_from_frequency(frequency, claw)*1e3;
    
 //   int resTurnRad = 8*w_res;
 //   int resTurnRad = 5*w_res; //MIPT
	int resTurnRad = 6*w_res;

    generateStructure(curCell, cursor, w_res, tailLen, length, resTurnRad, aux2);
    generateStructure(curCell, cursor, w_res+2*g_res, tailLen+g_res, length+g_res, resTurnRad, aux3);
    
    rotateLayer(curCell, aux2, couplingPoint, angleFromDirection(direction));
    rotateLayer(curCell, aux3, couplingPoint, angleFromDirection(direction));
    
  //  if (direction=="u") {
    //    mirrorLayer(curCell, aux2, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
   //     mirrorLayer(curCell, aux3, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
   // }
        
    layout->booleanTool->boolOnLayer(aux2, aux2, M, "A+B", 0, 0, 0);
    layout->booleanTool->boolOnLayer(aux3, aux3, protect, "A+B", 0, 0, 0);
    
    clearAllAuxiliaryAux(curCell);
    
    point retPoint;
    retPoint.set(200e3+resTurnRad, -(g_res+w_res/2+resTurnRad+tailLen));
    return rotateVector(retPoint, couplingPoint, direction);
}

point generateStructureHalfwaveTransmission(cell* curCell, point start, int width, int length, int resTurnRad, int layer){
        
        int curLength = 0;
        int tails_len = .7e6;
    
    
    point cursor = copyPoint(start);
    cursor = wire(curCell, layer, cursor, "d", tails_len, width);
    curLength += tails_len;
    
    cursor = torusTurn(curCell, layer, cursor, "dl", resTurnRad, width);
    cursor = wire(curCell, layer, cursor, "l", meanderSegmentLength/2, width);
    cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
    cursor = torusTurn(curCell, layer, cursor, "dr", resTurnRad, width);
    curLength += math::pi_2*3*resTurnRad + meanderSegmentLength/2;
    
    int meanderStepLength = 2*meanderSegmentLength+2*math::pi*resTurnRad;
    int meander_periods = 0;
    while (curLength + meanderStepLength < (length/2 - meanderSegmentLength-math::pi*resTurnRad)) {
        meander_periods+=1;
        cursor = drawMeanderStep(curCell, layer, cursor, meanderSegmentLength, resTurnRad, width);
        curLength+=meanderStepLength;
    }
    
    cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength/2, width);
    cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
    curLength += meanderSegmentLength/2 + math::pi_2*resTurnRad;

    cursor = wire(curCell, layer, cursor, "d", length - curLength*2, width);
    curLength += length-curLength*2;

    cursor = torusTurn(curCell, layer, cursor, "dl", resTurnRad, width);
    cursor = wire(curCell, layer, cursor, "l", meanderSegmentLength/2, width);
    cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
    cursor = torusTurn(curCell, layer, cursor, "dr", resTurnRad, width);
    curLength += math::pi_2*3*resTurnRad + meanderSegmentLength/2;
 
    int i;
    for (i=0; i<meander_periods; i++) {
        cursor = drawMeanderStep(curCell, layer, cursor, meanderSegmentLength, resTurnRad, width);
        curLength+=meanderStepLength;
    }   

    cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength/2, width);
    cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
    curLength += math::pi_2*resTurnRad + meanderSegmentLength/2;
    
    cursor = wire(curCell, layer, cursor, "d", length-curLength, width));
    return cursor;
}

point addHalfwaveTransmissionResonator(cell* curCell, point start, int w_res, int g_res, double frequency, string direction) {

        int length = length_from_frequency(frequency, false)*2*1e3;
        int resTurnRad = 5*w_res;
        point cursor;
        
        int l_tooth = 50e3;
        int w_tooth = 2.5e3;
        int w_gap= 7.5e3;
        int transition_len = 50e3;
        int n_teeth = 3;

        int idc_len = l_tooth+transition_len;        
    
    point resonator_start = rotateVector(newPoint(0, -idc_len), start, direction);

    addIDC(curCell, resonator_start, w_res, g_res, transition_len, w_tooth, w_gap, l_tooth, n_teeth, opposite(direction), true);
    
    generateStructureHalfwaveTransmission(curCell, resonator_start, w_res, length, resTurnRad, aux);
    cursor = generateStructureHalfwaveTransmission(curCell, resonator_start, w_res+2*g_res, length, resTurnRad, aux2);
    
    rotateLayer(curCell, aux, resonator_start, angleFromDirection(direction));
    rotateLayer(curCell, aux2, resonator_start, angleFromDirection(direction));
    cursor = rotateVector(newPoint(cursor.x()-resonator_start.x(), cursor.y()-resonator_start.y()), resonator_start, direction);
    
    layout->booleanTool->boolOnLayer(aux, aux, M, "A+B", 0, 0, 0);
    layout->booleanTool->boolOnLayer(aux2, aux2, protect, "A+B", 0, 0, 0);
    
    clearLayer(curCell, aux);
    clearAllAuxiliaryAux(curCell);
    
    addIDC(curCell, cursor, w_res, g_res, transition_len, w_tooth, w_gap, l_tooth, n_teeth, direction, true);
    
    return newPoint(cursor.x()+transition_len+l_tooth, cursor.y()); // now only for horizontal left to right resonators
    
}

int generateStructureCexp(cell* curCell, point cursor,  int width, int length,  int resTurnRad, int layer, int short_tail) {
    
        int curLength = 0;
        int tail_len = 300e3;
        point start;
        start.set(cursor.x(), cursor.y());
    
    if (short_tail == 1) {
        cursor.set(start.x()+tail_len/2, start.y());
    } else if (layer==aux3) {
        cursor.set(start.x()+tail_len/2+4*g_res, start.y());
        tail_len+=4*g_res;
    } else if(layer==aux2) {
        cursor.set(start.x()+tail_len/2, start.y());
    }

    
    cursor = wire(curCell, layer, cursor, "l", tail_len, width);
    curLength+=tail_len;
    cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    cursor = wire(curCell, layer, cursor, "d", 200e3, width);
    curLength+=200e3;
    cursor = torusTurn(curCell, layer, cursor, "dr", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    
    int meanderStepLength = 2*meanderSegmentLength+2*math::pi*resTurnRad;

    point cursor2;
    while ((length -curLength)>meanderStepLength) {
        cursor = drawMeanderStep(curCell, layer, cursor, meanderSegmentLength, resTurnRad, width);
        curLength+=meanderStepLength;
    }
    
    if (length - curLength >= meanderSegmentLength+2*resTurnRad*math::pi_2) {
        cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength, width);
        cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
        cursor = torusTurn(curCell, layer, cursor, "dl", resTurnRad, width);
        curLength+= meanderSegmentLength+2*resTurnRad*math::pi_2;
        if (length - curLength >= meanderSegmentLength) {
            cursor = wire(curCell, layer, cursor, "l", meanderSegmentLength, width);
            curLength += meanderSegmentLength;
            cursor = torusArbAngleTurn(curCell, layer, cursor, "ld", resTurnRad, width, (length-curLength)/2/math::pi/resTurnRad*360);
        } else {
            cursor = wire(curCell, layer, cursor, "l", length - curLength, width);
        }
    } else if (length - curLength >= meanderSegmentLength) {
        cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength, width);
        curLength+=meanderSegmentLength;
        cursor = torusArbAngleTurn(curCell, layer, cursor, "rd", resTurnRad, width, (length-curLength)/2/math::pi/resTurnRad*360);
    } else {
        cursor = wire(curCell, layer, cursor, "r", length - curLength, width);
        curLength+=length - curLength;
    }   
}

point addResonatorCexp(cell* curCell, point couplingPoint, int w_res, int g_res, double frequency, string direction, int short_tail=1) {

        point cursor;
        cursor.set(couplingPoint.x(), couplingPoint.y()-w_res/2 - g_res);
        int length = length_from_frequency(frequency, 0)*1e3;
    
        int resTurnRad = 10*w_res;
        
    generateStructureCexp(curCell, cursor, w_res,             length, resTurnRad, aux2, short_tail);
    generateStructureCexp(curCell, cursor, w_res+2*g_res, length+4*g_res, resTurnRad, aux3, short_tail);
    
    rotateLayer(curCell, aux2, couplingPoint, angleFromDirection(direction));
    rotateLayer(curCell, aux3, couplingPoint, angleFromDirection(direction));
    if (direction=="u") {
        mirrorLayer(curCell, aux2, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
        mirrorLayer(curCell, aux3, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
    }
        
    layout->booleanTool->boolOnLayer(aux2, aux2, M, "A+B", 0, 0, 0);
    layout->booleanTool->boolOnLayer(aux3, aux3, protect, "A+B", 0, 0, 0);
    
    clearAllAuxiliaryAux(curCell);
    
    point retPoint;
    retPoint.set(200e3+resTurnRad, -(g_res+w_res/2+resTurnRad+tailLen));
    return rotateVector(retPoint, couplingPoint, direction);
}

point addResonatorNoMeander(cell* curCell, point couplingPoint, int w_res, int g_res, double frequency, int tailLen, string direction, bool claw) {
    
    point cursor;
    cursor.set(couplingPoint.x(), couplingPoint.y()-w_res/2 - g_res);
    
    int length = length_from_frequency(frequency, claw)*1e3;
    int resTurnRad = 8*w_res;
    int curLength = 0;
    point start;
    start.set(cursor.x(), cursor.y());
    int layer = aux2;
    int width = w_res;
    int i;
    for (i=0; i<2; i++) {
        curLength = 0;
        cursor = wire(curCell, layer, start, "r", 200e3, width);
        curLength+=200e3;
        cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
        curLength+=resTurnRad*math::pi_2;
        cursor = wire(curCell, layer, cursor, "d", tailLen, width);
        curLength+=tailLen;
        
        cursor.set(start.x(), start.y());
        
        cursor = wire(curCell, layer, cursor, "l", 200e3, width);
        curLength+=200e3;
        cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
        curLength+=resTurnRad*math::pi_2;
        cursor = wire(curCell, layer, cursor, "d", length-curLength, width);
        width = 2*g_res+w_res;
        tailLen += g_res;
        length += g_res;
        layer = aux3;
    }
    
    rotateLayer(curCell, aux2, couplingPoint, angleFromDirection(direction));
    rotateLayer(curCell, aux3, couplingPoint, angleFromDirection(direction));
    //if (direction=="u") {
    //    mirrorLayer(curCell, aux2, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
   //     mirrorLayer(curCell, aux3, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
    //}
    
    layout->booleanTool->boolOnLayer(aux2, aux2, M, "A+B", 0, 0, 0);
    layout->booleanTool->boolOnLayer(aux3, aux3, protect, "A+B", 0, 0, 0);
    
    clearAllAuxiliaryAux(curCell);
    
    point retPoint;
    retPoint.set(200e3+resTurnRad, -(g_res+w_res/2+resTurnRad+tailLen));
    return rotateVector(retPoint, couplingPoint, direction);


}
